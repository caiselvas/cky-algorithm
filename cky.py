from typing import Any
from cfg import CFG

class CKY:
	def __init__(self, grammar: CFG|None=None) -> None:
		"""
		Initializes the CKY parser with a given Context-Free Grammar (CFG) in Chomsky Normal Form (CNF).

		Parameters
		----------
		grammar (CFG, None): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
			If None, the grammar must be set later using the set_grammar method or by passing it as an argument to the parse method.
		"""
		self.grammar: CFG|None = grammar

	def __call__(self, *args: Any, **kwargs: Any) -> bool:
		"""
		Allows the CKY parser to be called as a function.

		Parameters
		----------
		*args (Any): Positional arguments to pass to the parse method.
		**kwargs (Any): Keyword arguments to pass to the parse method.

		Returns
		-------
		bool
			The result of the parse method call.
		"""
		return self.parse(*args, **kwargs)

	def set_grammar(self, grammar: CFG) -> None:
		"""
		Sets the grammar to use for parsing.

		Parameters
		----------
		grammar (CFG): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
		"""
		self.grammar = grammar

	def parse(self, word: str, grammar: CFG|None=None, probabilistic: bool=False) -> bool:
		"""
		Parses a given word using the CKY algorithm.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing. If None, the grammar previously set is used.
		probabilistic (bool): Whether to use probabilistic parsing. Default is False, which uses deterministic parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		assert (grammar is not None) or (self.grammar is not None), "A grammar must be provided or set before parsing."

		if grammar is None:
			grammar = self.grammar

		# Probabilistic parsing
		if probabilistic:
			return self.__parse_probabilistic(word, grammar)

		# Deterministic parsing
		else:
			return self.__parse_deterministic(word, grammar)

	def __parse_deterministic(self, word: str, grammar: CFG) -> bool:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		n = len(word)

		if n == 0:
			return grammar.EPSILON in grammar(grammar.get_start_symbol())
		
		table = [[set() for _ in range(n)] for _ in range(n)]
		
		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if char in productions:
					table[i][i].add(lhs)
		
		# Fill the table for non-terminals
		for span in range(2, n+1):  # span length
			for start in range(n-span+1):  # start of the span
				end = start + span - 1  # end of the span
				for split in range(start, end):
					left_cell = table[start][split]
					right_cell = table[split+1][end]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[start][end].add(lhs)
		
		# Check if the start symbol is in the top right cell
		return grammar.get_start_symbol() in table[0][n-1]
	

	def parse_deterministic2(self, word: str, grammar: CFG) -> bool:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		n = len(word)

		if n == 0:
			return grammar.EPSILON in grammar(grammar.get_start_symbol())
		
		# Create a triangular table where table[i] has size (n-i)
		table = [ [set() for _ in range(n - i)] for i in range(n) ]
		
		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if char in productions:
					table[0][i].add(lhs)
		
		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(start, start + span - 1):
					left_cell = table[split - start][start]
					right_cell = table[start + span - 1 - (split + 1)][split + 1]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[span - 1][start].add(lhs)
		
		# Check if the start symbol is in the top right cell
		return grammar.get_start_symbol() in table[n - 1][0]


	def __parse_probabilistic(self, word: str, grammar: CFG) -> bool:
		"""
		Parses a given word using the CKY algorithm probabilistically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		n = len(word)
		
		table = [[{} for _ in range(n)] for _ in range(n)]

		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				for production in productions:
					if char == production:
						table[i][i][lhs] = 1.0  # Probabilistic score for terminals

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				end = start + span - 1  # end of the span
				for split in range(start, end):
					left_cell = table[start][split]
					right_cell = table[split + 1][end]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2:
								B, C = production
								if B in left_cell and C in right_cell:
									prob = left_cell[B] * right_cell[C]
									if lhs in table[start][end]:
										table[start][end][lhs] = max(table[start][end][lhs], prob)
									else:
										table[start][end][lhs] = prob

		# Check if the start symbol is in the top right cell
		return grammar.get_start_symbol() in table[0][n - 1] and table[0][n - 1][grammar.get_start_symbol()] > 0
