from typing import Any
from cfg import CFG, PCFG

class CKY:
	def __init__(self, grammar: CFG|None=None) -> None:
		"""
		Initializes the CKY parser with a given Context-Free Grammar (CFG) in Chomsky Normal Form (CNF).

		Parameters
		----------
		grammar (CFG, None): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
			If None, the grammar must be set later using the set_grammar method or by passing it as an argument to the parse method.
		"""
		self.grammar: CFG|None = grammar

	def __call__(self, *args: Any, **kwargs: Any) -> bool:
		"""
		Allows the CKY parser to be called as a function.

		Parameters
		----------
		*args (Any): Positional arguments to pass to the parse method.
		**kwargs (Any): Keyword arguments to pass to the parse method.

		Returns
		-------
		bool
			The result of the parse method call.
		"""
		return self.parse(*args, **kwargs)

	def set_grammar(self, grammar: CFG) -> None:
		"""
		Sets the grammar to use for parsing.

		Parameters
		----------
		grammar (CFG): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
		"""
		self.grammar = grammar

	def parse(self, word: str, grammar: CFG|None=None, probabilistic: bool=False) -> bool:
		"""
		Parses a given word using the CKY algorithm.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing. If None, the grammar previously set is used.
		probabilistic (bool): Whether to use probabilistic parsing. Default is False, which uses deterministic parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		assert (grammar is not None) or (self.grammar is not None), "A grammar must be provided or set before parsing."

		if grammar is None:
			grammar = self.grammar
		
		# If gramamar is a PCFG, use probabilistic parsing

		if isinstance(grammar, PCFG):
			return self.__parse_probabilistic(word, grammar)
		elif isinstance(grammar, CFG):
			return self.__parse_deterministic(word, grammar)
		else:
			raise ValueError("Invalid grammar type. Expected CFG or PCFG.")
	

	def __parse_deterministic(self, word: str, grammar: CFG) -> bool:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		n = len(word)

		if n == 0:
			return grammar.EPSILON in grammar(grammar.get_start_symbol())
		
		# Create a triangular table where table[i] has size (n-i)
		table = [ [set() for _ in range(n - i)] for i in range(n) ]
		
		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if char in productions:
					table[0][i].add(lhs)
		
		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(start, start + span - 1):
					left_cell = table[split - start][start]
					right_cell = table[start + span - 1 - (split + 1)][split + 1]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[span - 1][start].add(lhs)
		
		# Check if the start symbol is in the top right cell
		return grammar.get_start_symbol() in table[n - 1][0]
	

	def __parse_probabilistic(self, word: str, grammar: PCFG) -> float:
		"""
		Parses a given word using the CKY algorithm probabilistically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (PCFG): The grammar to use for parsing.

		Returns
		-------
		float
			The probability of the word being in the language generated by the grammar.
		"""
		n = len(word)

		if n == 0:
			return 1.0 if grammar.EPSILON in grammar(grammar.get_start_symbol()) else 0.0

		# Create a triangular table where table[i] has size (n-i)
		table = [ [{} for _ in range(n - i)] for i in range(n) ]

		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				for production, prob in productions:
					if production == char:
						table[0][i][lhs] = prob

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(start, start + span - 1):
					left_cell = table[split - start][start]
					right_cell = table[start + span - 1 - (split + 1)][split + 1]
					for lhs, productions in grammar.get_rules().items():
						for production, prob in productions:
							if len(production) == 2:
								B, C = production
								if B in left_cell and C in right_cell:
									prob_B = left_cell[B]
									prob_C = right_cell[C]
									if lhs in table[span - 1][start]:
										table[span - 1][start][lhs] += prob * prob_B * prob_C
									else:
										table[span - 1][start][lhs] = prob * prob_B * prob_C

		# Return the probability of the start symbol being in the top right cell
		return table[n - 1][0].get(grammar.get_start_symbol(), 0.0)

	
	def __parse_deterministic_old(self, word: str, grammar: CFG) -> bool:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		n = len(word)

		if n == 0:
			return grammar.EPSILON in grammar(grammar.get_start_symbol())
		
		table = [[set() for _ in range(n)] for _ in range(n)]
		
		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if char in productions:
					table[i][i].add(lhs)
		
		# Fill the table for non-terminals
		for span in range(2, n+1):  # span length
			for start in range(n-span+1):  # start of the span
				end = start + span - 1  # end of the span
				for split in range(start, end):
					left_cell = table[start][split]
					right_cell = table[split+1][end]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[start][end].add(lhs)
		
		# Check if the start symbol is in the top right cell
		return grammar.get_start_symbol() in table[0][n-1]
	
	def __parse_probabilistic_old(self, word: str, grammar: CFG) -> bool:
		"""
		Parses a given word using the CKY algorithm probabilistically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		bool
			True if the word is in the language generated by the grammar, False otherwise.
		"""
		n = len(word)
		
		table = [[{} for _ in range(n)] for _ in range(n)]

		# Fill the diagonal of the table for terminals
		for i, char in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				for production in productions:
					if char == production:
						table[i][i][lhs] = 1.0  # Probabilistic score for terminals

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				end = start + span - 1  # end of the span
				for split in range(start, end):
					left_cell = table[start][split]
					right_cell = table[split + 1][end]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2:
								B, C = production
								if B in left_cell and C in right_cell:
									prob = left_cell[B] * right_cell[C]
									if lhs in table[start][end]:
										table[start][end][lhs] = max(table[start][end][lhs], prob)
									else:
										table[start][end][lhs] = prob

		# Check if the start symbol is in the top right cell
		return grammar.get_start_symbol() in table[0][n - 1] and table[0][n - 1][grammar.get_start_symbol()] > 0
