from collections import deque, defaultdict

class CFG:
	def __init__(self, start_symbol, productions):
		self.start_symbol = start_symbol
		self.productions = productions
	
	def generate_words(self, max_length: int) -> set:
		"""
		Generates all possible words up to a certain length that can be generated by the grammar.

		Warning: Large values of max_length may take a long time to generate all possible words and consume a lot of memory.

		Parameters
		----------
		max_length (int): The maximum length of the words to generate.

		Returns
		-------
		set
			Set of all possible words up to the maximum length that can be generated by the grammar.
		"""
		assert max_length > 0, "The maximum length must be greater than 0."

		words = set()
		queue = deque([(self.start_symbol, '')])
		visited = set()
		num_generated_words = 0
		
		# Precompute production lengths
		production_lengths = defaultdict(list)
		for symbol, productions in self.productions.items():
			for production in productions:
				production_lengths[symbol].append((production, len(production)))
		
		while queue:
			current_string, current_word = queue.popleft()

			# If the current word exceeds the maximum length, skip it
			if len(current_string) > max_length:
				continue

			# If current_string is fully expanded (all terminals), add to words
			if all(symbol not in self.productions for symbol in current_string):
				if len(current_string) <= max_length:
					words.add(current_string)
					num_generated_words += 1
					print(f"Number of words generated: {num_generated_words}", end='\r')
				continue

			# Process each symbol in the current string
			for i, symbol in enumerate(current_string):
				if symbol in self.productions:
					for production, prod_length in production_lengths[symbol]:
						new_string = current_string[:i] + production + current_string[i+1:]
						if len(new_string) <= max_length and new_string not in visited:
							visited.add(new_string)
							queue.append((new_string, current_word))
					break  # Only expand the first non-terminal symbol

		return words


grammar1 = {
	'S': ['ASB'],
	'A': ['a', 'aS', ''],
	'B': ['A', 'SbS', 'bb']
}

grammar2 = {
	'S': ['AS', 'EB', 'SB'],
	'A': ['DS', 'GS', 'a'],
	'B': ['DS', 'FS', 'GS', 'HH', 'a'],
	'D': ['GA'],
	'E': ['AS'],
	'F': ['SH'],
	'G': ['a'],
	'H': ['b']
}

cfg1 = CFG('S', grammar1)
cfg2 = CFG('S', grammar2)

words1 = cfg1.generate_words(5)
words2 = cfg2.generate_words(5)

print(words1)
print(words2)

print(words1 == words2)