from typing import Any
from src.cfg import CFG
from collections import defaultdict

class CKY:
	"""
	A class to represent a CKY parser for Context-Free Grammars (CFG) or Probabilistic Context-Free Grammars (PCFG) in Chomsky Normal Form (CNF).
	"""
	def __init__(self, grammar: CFG|None=None) -> None:
		"""
		Initializes the CKY parser with a given Context-Free Grammar (CFG) in Chomsky Normal Form (CNF).

		Parameters
		----------
		grammar (CFG, None): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
			If None, the grammar must be set later using the set_grammar method or by passing it as an argument to the parse method.
		"""
		self.grammar: CFG|None = grammar

	def __call__(self, *args: Any, **kwargs: Any) -> bool | tuple[bool, float]:
		"""
		Allows the CKY parser to be called as a function.

		Parameters
		----------
		*args (Any): Positional arguments to pass to the parse method.
		**kwargs (Any): Keyword arguments to pass to the parse method.

		Returns
		-------
		bool | tuple[bool, float]
			The result of the parse method call.
		"""
		return self.parse(*args, **kwargs)

	def set_grammar(self, grammar: CFG) -> None:
		"""
		Sets the grammar to use for parsing.

		Parameters
		----------
		grammar (CFG): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
		"""
		self.grammar = grammar

	def parse(self, word: str, grammar: CFG|None=None) -> bool|tuple[bool, float]:
		"""
		Parses a given word using the CKY algorithm.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing. If None, the grammar previously set is used.

		Returns
		-------
		bool
			
		"""
		assert (grammar is not None) or (self.grammar is not None), "A grammar must be provided or set before parsing."

		if grammar is None:
			grammar = self.grammar
		
		if isinstance(grammar, CFG):
			if grammar.is_probabilistic():
				return self.__parse_probabilistic(word, grammar) # Returns a tuple (bool, float)
			else:
				return self.__parse_deterministic(word, grammar) # Returns a boolean
		else:
			raise ValueError("Invalid grammar type. Expected CFG object.")

	def __parse_deterministic(self, word: str, grammar: CFG) -> tuple[bool, list]:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		tuple[bool, list]
			A tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			and a list of possible parse trees.
		"""
		n = len(word)

		start_symbol = grammar.get_start_symbol()

		if n == 0:
			return (grammar.EPSILON in grammar(start_symbol), [])

		# Create a triangular table where table[i] has size (n-i)
		table = [ [set() for _ in range(n - i)] for i in range(n) ]
		backpointers = [ [{} for _ in range(n - i)] for i in range(n) ]

		# Fill the diagonal of the table for terminals
		for i, sym in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if sym in productions:
					table[0][i].add(lhs)
					if lhs not in backpointers[0][i]:
						backpointers[0][i][lhs] = []
					backpointers[0][i][lhs].append((sym,))

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(start, start + span - 1):
					left_cell = table[split - start][start]
					right_cell = table[start + span - 1 - (split + 1)][split + 1]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[span - 1][start].add(lhs)
								if lhs not in backpointers[span - 1][start]:
									backpointers[span - 1][start][lhs] = []
								backpointers[span - 1][start][lhs].append((production[0], production[1], split - start, split + 1))

		# Check if the start symbol is in the top right cell
		result = grammar.start_symbol in table[n - 1][0]

		# Retrieve all possible parse trees
		parse_trees = []
		if result:
			def build_trees(symbol, i, j):
				if j - i == 1:
					return [(symbol, word[i])]
				trees = []
				for left, right, left_span, right_span in backpointers[j - i - 1][i][symbol]:
					left_trees = build_trees(left, i, i + left_span + 1)
					right_trees = build_trees(right, i + left_span + 1, j)
					for lt in left_trees:
						for rt in right_trees:
							trees.append((symbol, lt, rt))
				return trees

			parse_trees = build_trees(start_symbol, 0, n)

		return result, parse_trees

	
	
	def __parse_probabilistic(self, word: str, grammar: CFG) -> tuple[bool, float]:
		"""
		Parses a given word using the CKY algorithm probabilistically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		tuple[bool, float]
			A tuple containing a boolean indicating whether the word is in the language generated by the grammar 
			and the probability of the word being generated by the grammar.
		"""
		n = len(word)
		
		start_symbol = grammar.get_start_symbol()

		if n == 0:
			return (True, grammar.get_probability(start_symbol, grammar.EPSILON)) \
				if grammar.EPSILON in grammar(start_symbol) \
				else (False, 0.0)
		
		# Create a triangular table where table[i] has size (n-i)
		table = [[defaultdict(float) for _ in range(n - i)] for i in range(n)]
		
		# Fill the diagonal of the table for terminals
		for i, sym in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if sym in productions:
					table[0][i][lhs] = grammar.get_probability(lhs, sym)
		
		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(1, span):  # split point within the span
					left_cell = table[split - 1][start]
					right_cell = table[span - split - 1][start + split]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2:
								B, C = production
								if B in left_cell and C in right_cell:
									prob = grammar.get_probability(lhs, production) * left_cell[B] * right_cell[C]
									if prob > 0:
										table[span - 1][start][lhs] += prob
		
		# Return the probability of the start symbol generating the whole word
		result_prob = table[n - 1][0].get(start_symbol, 0.0)

		return (True, result_prob) if result_prob > 0 else (False, 0.0)

