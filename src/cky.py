from typing import Any
from src.cfg import CFG
from collections import defaultdict
import warnings
from src.functions import dynamic_round, transform_probabilistic_to_deterministic, visualize_parse_trees

class CKY:
	"""
	A class to represent a CKY parser for Context-Free Grammars (CFG) or Probabilistic Context-Free Grammars (PCFG) in Chomsky Normal Form (CNF).
	"""
	def __init__(self, grammar: CFG|None=None) -> None:
		"""
		Initializes the CKY parser with a given Context-Free Grammar (CFG) in Chomsky Normal Form (CNF).

		Parameters
		----------
		grammar (CFG, None): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
			If None, the grammar must be set later using the set_grammar method or by passing it as an argument to the parse method.
		"""
		self.grammar: CFG|None = grammar

	def __call__(self, *args: Any, **kwargs: Any) -> tuple[bool, list]|tuple[bool, float, list]:
		"""
		Allows the CKY parser to be called as a function.

		Parameters
		----------
		*args (Any): Positional arguments to pass to the parse method.
		**kwargs (Any): Keyword arguments to pass to the parse method.

		Returns
		-------
		bool | tuple[bool, float]
			The result of the parse method call.
		"""
		return self.parse(*args, **kwargs)

	def set_grammar(self, grammar: CFG) -> None:
		"""
		Sets the grammar to use for parsing.

		Parameters
		----------
		grammar (CFG): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
		"""
		self.grammar = grammar

	def parse(self, word: str, grammar: CFG|None=None, round_probabilities: bool=False, visualize: bool=False) -> tuple[bool, list]|tuple[bool, float, list]:
		"""
		Parses a given word using the CKY algorithm.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing. If None, the grammar previously set is used.
		round_probabilities (bool): Whether to use dynamic rounding for the probabilities (with default theshold) or not. Default is False.
			This helps fixing the floating point errors in the probabilities.
			If the provided grammar is deterministic, this parameter is ignored.
		visualize (bool): Whether to visualize the parse trees using the nltk library. Default is False.

		Returns
		-------
		tuple[bool, list] | tuple[bool, float, list]
			If the grammar is deterministic, returns a tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			and a list of possible parse trees.
			If the grammar is probabilistic, returns a tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			the total probability of the word being generated by the grammar, and a list of tuples with parse trees and their probabilities.
			
		"""
		assert (grammar is not None) or (self.grammar is not None), "A grammar must be provided or set before parsing."
		if any(c.isupper() for c in word):
			warnings.warn("The word contains uppercase characters. Converting to lowercase.", UserWarning)
			word = word.lower()

		if grammar is None:
			grammar = self.grammar
		
		if isinstance(grammar, CFG):
			if grammar.is_probabilistic():
				return self.__parse_probabilistic(word, grammar, round_probabilities, visualize) # Returns a tuple (bool, float, list)
			else:
				if self.grammar is not None:
					warnings.warn("Rounding probabilities is only available for probabilistic grammars. No rounding will be applied because the grammar is deterministic.", UserWarning)
				return self.__parse_deterministic(word, grammar, visualize) # Returns a tuple (bool, list)
		else:
			raise ValueError("Invalid grammar type. Expected CFG object.")

	def __parse_deterministic(self, word: str, grammar: CFG, visualize: bool) -> tuple[bool, list]:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		tuple[bool, list]
			A tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			and a list of possible parse trees.
		"""
		n = len(word)

		start_symbol = grammar.get_start_symbol()

		if n == 0:
			return (grammar.EPSILON in grammar(start_symbol), [])

		# Create a triangular table where table[i] has size (n-i)
		table = [ [set() for _ in range(n - i)] for i in range(n) ]
		backpointers = [ [{} for _ in range(n - i)] for i in range(n) ]

		# Fill the diagonal of the table for terminals
		for i, sym in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if sym in productions:
					table[0][i].add(lhs)
					if lhs not in backpointers[0][i]:
						backpointers[0][i][lhs] = []
					backpointers[0][i][lhs].append((sym,))

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(start, start + span - 1):
					left_cell = table[split - start][start]
					right_cell = table[start + span - 1 - (split + 1)][split + 1]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[span - 1][start].add(lhs)
								if lhs not in backpointers[span - 1][start]:
									backpointers[span - 1][start][lhs] = []
								backpointers[span - 1][start][lhs].append((production[0], production[1], split - start, split + 1))

		# Check if the start symbol is in the top right cell
		result = grammar.start_symbol in table[n - 1][0]

		# Retrieve all possible parse trees
		parse_trees = []
		if result:
			def build_trees(symbol, i, j):
				if j - i == 1:
					return [(symbol, word[i])]
				
				trees = []
				for left, right, left_span, right_span in backpointers[j - i - 1][i][symbol]:
					left_trees = build_trees(left, i, i + left_span + 1)
					right_trees = build_trees(right, i + left_span + 1, j)
					for lt in left_trees:
						for rt in right_trees:
							trees.append((symbol, lt, rt))
				
				return trees

			parse_trees = build_trees(start_symbol, 0, n)

		# Visualize the parse trees
		if visualize:
			visualize_parse_trees(parse_trees, word=word, prob=False)
			
		return result, parse_trees

	
	def __parse_probabilistic(self, word: str, grammar: CFG, round_probabilities, visualize: bool) -> tuple[bool, float, list]:
		"""
		Parses a given word using the CKY algorithm probabilistically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.
		round_probabilities (bool): Whether to use dynamic rounding for the probabilities (with default theshold) or not. Default is False.
			This helps fixing the floating point errors in the probabilities.			

		Returns
		-------
		tuple[bool, float, list]
			A tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			the total probability of the word being generated by the grammar, and a list of tuples with parse trees and their probabilities.
		"""
		n = len(word)

		start_symbol = grammar.get_start_symbol()

		if n == 0:
			if grammar.EPSILON in grammar(start_symbol):
				return (True, grammar.get_probability(start_symbol, grammar.EPSILON), [(grammar.EPSILON, grammar.get_probability(start_symbol, grammar.EPSILON))])
			else:
				return (False, 0.0, [])

		# Create a triangular table where table[i] has size (n-i)
		table = [[defaultdict(float) for _ in range(n - i)] for i in range(n)]
		backpointers = [[defaultdict(list) for _ in range(n - i)] for i in range(n)]

		# Fill the diagonal of the table for terminals
		for i, sym in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if sym in productions:
					prob = grammar.get_probability(lhs, sym)
					table[0][i][lhs] = prob
					backpointers[0][i][lhs].append((sym, prob))

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(1, span):  # split point within the span
					left_cell = table[split - 1][start]
					right_cell = table[span - split - 1][start + split]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2:
								B, C = production
								if B in left_cell and C in right_cell:
									prob = grammar.get_probability(lhs, production) * left_cell[B] * right_cell[C]
									if prob > 0:
										table[span - 1][start][lhs] += prob
										backpointers[span - 1][start][lhs].append((B, C, split))

		# Return the probability of the start symbol generating the whole word
		result_prob = table[n - 1][0].get(start_symbol, 0.0)

		# Retrieve all possible parse trees with their probabilities
		parse_trees_with_probs = []
		if result_prob > 0:
			def build_trees_with_probs(symbol, i, j):
				if j - i == 1:
					return [(symbol, word[i], table[0][i][symbol])]
				
				trees_with_probs = []
				for left, right, split in backpointers[j - i - 1][i][symbol]:
					left_prob = table[split - 1][i][left]
					right_prob = table[j - i - split - 1][i + split][right]
					prod_prob = grammar.get_probability(symbol, left + right)
					left_trees = build_trees_with_probs(left, i, i + split)
					right_trees = build_trees_with_probs(right, i + split, j)
					for lt in left_trees:
						for rt in right_trees:
							combined_prob = left_prob * right_prob * prod_prob
							if round_probabilities:
								combined_prob = dynamic_round(combined_prob)
							trees_with_probs.append(((symbol, lt, rt), combined_prob))
				
				return trees_with_probs

			parse_trees_with_probs = build_trees_with_probs(start_symbol, 0, n)

		# Calculate the total probability from all paths
		if round_probabilities:
			total_prob = dynamic_round(sum(prob for _, prob in parse_trees_with_probs))
		else:
			total_prob = sum(prob for _, prob in parse_trees_with_probs)
		
		# Visualize the parse trees
		if visualize:
			visualize_parse_trees(parse_trees_with_probs, word=word, prob=True)

		return (total_prob > 0, total_prob, parse_trees_with_probs)