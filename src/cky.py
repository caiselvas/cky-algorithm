from typing import Any
from src.cfg import CFG
from collections import defaultdict
import warnings
from src.functions import dynamic_round
import matplotlib.pyplot as plt
import networkx as nx

class CKY:
	"""
	A class to represent a CKY parser for Context-Free Grammars (CFG) or Probabilistic Context-Free Grammars (PCFG) in Chomsky Normal Form (CNF).
	"""
	def __init__(self, grammar: CFG|None=None) -> None:
		"""
		Initializes the CKY parser with a given Context-Free Grammar (CFG) in Chomsky Normal Form (CNF).

		Parameters
		----------
		grammar (CFG, None): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
			If None, the grammar must be set later using the set_grammar method or by passing it as an argument to the parse method.
		"""
		self.grammar: CFG|None = grammar

	def __call__(self, *args: Any, **kwargs: Any) -> tuple[bool, list]|tuple[bool, float, list]:
		"""
		Allows the CKY parser to be called as a function.

		Parameters
		----------
		*args (Any): Positional arguments to pass to the parse method.
		**kwargs (Any): Keyword arguments to pass to the parse method.

		Returns
		-------
		bool | tuple[bool, float]
			The result of the parse method call.
		"""
		return self.parse(*args, **kwargs)

	def set_grammar(self, grammar: CFG) -> None:
		"""
		Sets the grammar to use for parsing.

		Parameters
		----------
		grammar (CFG): The object representing the Context-Free Grammar (CFG) in Chomsky Normal Form (CNF) to use for parsing.
		"""
		self.grammar = grammar

	def parse(self, word: str, grammar: CFG|None=None, round_probabilities: bool=False, visualize: bool=False) -> tuple[bool, list]|tuple[bool, float, list]:
		"""
		Parses a given word using the CKY algorithm.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing. If None, the grammar previously set is used.
		round_probabilities (bool): Whether to use dynamic rounding for the probabilities (with default theshold) or not. Default is False.
			This helps fixing the floating point errors in the probabilities.
			If the provided grammar is deterministic, this parameter is ignored.
		visualize (bool): Whether to visualize the parse trees using the nltk library. Default is False.

		Returns
		-------
		tuple[bool, list] | tuple[bool, float, list]
			If the grammar is deterministic, returns a tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			and a list of possible parse trees.
			If the grammar is probabilistic, returns a tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			the total probability of the word being generated by the grammar, and a list of tuples with parse trees and their probabilities.
			
		"""
		assert (grammar is not None) or (self.grammar is not None), "A grammar must be provided or set before parsing."
		if any(c.isupper() for c in word):
			warnings.warn("The word contains uppercase characters. Converting to lowercase.", UserWarning)
			word = word.lower()

		if grammar is None:
			grammar = self.grammar
		
		if isinstance(grammar, CFG):
			if grammar.is_probabilistic():
				return self.__parse_probabilistic(word, grammar, round_probabilities, visualize) # Returns a tuple (bool, float, list)
			else:
				if self.grammar is not None:
					warnings.warn("Rounding probabilities is only available for probabilistic grammars. No rounding will be applied because the grammar is deterministic.", UserWarning)
				return self.__parse_deterministic(word, grammar, visualize) # Returns a tuple (bool, list)
		else:
			raise ValueError("Invalid grammar type. Expected CFG object.")

	def __parse_deterministic(self, word: str, grammar: CFG, visualize: bool) -> tuple[bool, list]:
		"""
		Parses a given word using the CKY algorithm deterministically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.

		Returns
		-------
		tuple[bool, list]
			A tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			and a list of possible parse trees.
		"""
		n = len(word)

		start_symbol = grammar.get_start_symbol()

		if n == 0:
			return (grammar.EPSILON in grammar(start_symbol), [])

		# Create a triangular table where table[i] has size (n-i)
		table = [ [set() for _ in range(n - i)] for i in range(n) ]
		backpointers = [ [{} for _ in range(n - i)] for i in range(n) ]

		# Fill the diagonal of the table for terminals
		for i, sym in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if sym in productions:
					table[0][i].add(lhs)
					if lhs not in backpointers[0][i]:
						backpointers[0][i][lhs] = []
					backpointers[0][i][lhs].append((sym,))

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(start, start + span - 1):
					left_cell = table[split - start][start]
					right_cell = table[start + span - 1 - (split + 1)][split + 1]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2 and production[0] in left_cell and production[1] in right_cell:
								table[span - 1][start].add(lhs)
								if lhs not in backpointers[span - 1][start]:
									backpointers[span - 1][start][lhs] = []
								backpointers[span - 1][start][lhs].append((production[0], production[1], split - start, split + 1))

		# Check if the start symbol is in the top right cell
		result = grammar.start_symbol in table[n - 1][0]

		# Retrieve all possible parse trees
		parse_trees = []
		if result:
			def build_trees(symbol, i, j):
				if j - i == 1:
					return [(symbol, word[i])]
				
				trees = []
				for left, right, left_span, right_span in backpointers[j - i - 1][i][symbol]:
					left_trees = build_trees(left, i, i + left_span + 1)
					right_trees = build_trees(right, i + left_span + 1, j)
					for lt in left_trees:
						for rt in right_trees:
							trees.append((symbol, lt, rt))
				
				return trees

			parse_trees = build_trees(start_symbol, 0, n)

		# Visualize the parse trees
		if visualize:
			self.visualize_parse_trees(parse_trees, word=word, prob=False)
			
		return result, parse_trees

	
	def __parse_probabilistic(self, word: str, grammar: CFG, round_probabilities, visualize: bool) -> tuple[bool, float, list]:
		"""
		Parses a given word using the CKY algorithm probabilistically.

		Parameters
		----------
		word (str): The word to parse.
		grammar (CFG): The grammar to use for parsing.
		round_probabilities (bool): Whether to use dynamic rounding for the probabilities (with default theshold) or not. Default is False.
			This helps fixing the floating point errors in the probabilities.			

		Returns
		-------
		tuple[bool, float, list]
			A tuple containing a boolean indicating whether the word is in the language generated by the grammar,
			the total probability of the word being generated by the grammar, and a list of tuples with parse trees and their probabilities.
		"""
		n = len(word)

		start_symbol = grammar.get_start_symbol()

		if n == 0:
			if grammar.EMPTY in grammar(start_symbol):
				return (True, grammar.get_probability(start_symbol, grammar.EMPTY), [(grammar.EMPTY, grammar.get_probability(start_symbol, grammar.EMPTY))])
			else:
				return (False, 0.0, [])

		# Create a triangular table where table[i] has size (n-i)
		table = [[defaultdict(float) for _ in range(n - i)] for i in range(n)]
		backpointers = [[defaultdict(list) for _ in range(n - i)] for i in range(n)]

		# Fill the diagonal of the table for terminals
		for i, sym in enumerate(word):
			for lhs, productions in grammar.get_rules().items():
				if sym in productions:
					prob = grammar.get_probability(lhs, sym)
					table[0][i][lhs] = prob
					backpointers[0][i][lhs].append((sym, prob))

		# Fill the table for non-terminals
		for span in range(2, n + 1):  # span length
			for start in range(n - span + 1):  # start of the span
				for split in range(1, span):  # split point within the span
					left_cell = table[split - 1][start]
					right_cell = table[span - split - 1][start + split]
					for lhs, productions in grammar.get_rules().items():
						for production in productions:
							if len(production) == 2:
								B, C = production
								if B in left_cell and C in right_cell:
									prob = grammar.get_probability(lhs, production) * left_cell[B] * right_cell[C]
									if prob > 0:
										table[span - 1][start][lhs] += prob
										backpointers[span - 1][start][lhs].append((B, C, split))

		# Return the probability of the start symbol generating the whole word
		result_prob = table[n - 1][0].get(start_symbol, 0.0)

		# Retrieve all possible parse trees with their probabilities
		parse_trees_with_probs = []
		if result_prob > 0:
			def build_trees_with_probs(symbol, i, j):
				if j - i == 1:
					return [(symbol, word[i], table[0][i][symbol])]
				
				trees_with_probs = []
				for left, right, split in backpointers[j - i - 1][i][symbol]:
					left_prob = table[split - 1][i][left]
					right_prob = table[j - i - split - 1][i + split][right]
					prod_prob = grammar.get_probability(symbol, left + right)
					left_trees = build_trees_with_probs(left, i, i + split)
					right_trees = build_trees_with_probs(right, i + split, j)
					for lt in left_trees:
						for rt in right_trees:
							combined_prob = left_prob * right_prob * prod_prob
							if round_probabilities:
								combined_prob = dynamic_round(combined_prob)
							trees_with_probs.append(((symbol, lt, rt), combined_prob))
				
				return trees_with_probs

			parse_trees_with_probs = build_trees_with_probs(start_symbol, 0, n)

		# Calculate the total probability from all paths
		if round_probabilities:
			total_prob = dynamic_round(sum(prob for _, prob in parse_trees_with_probs))
		else:
			total_prob = sum(prob for _, prob in parse_trees_with_probs)
		
		# Visualize the parse trees
		if visualize:
			self.visualize_parse_trees(parse_trees_with_probs, word=word, prob=True)

		return (total_prob > 0, total_prob, parse_trees_with_probs)
	

	def __transform_probabilistic_to_deterministic(self, parse_trees_with_probs):
		"""
		Function to transform probabilistic parse trees to deterministic parse trees.

		Parameters
		----------
		parse_trees_with_probs (list): A list of tuples with parse trees and their probabilities.

		Returns
		-------
		float, list
			The total probability of the parse trees and the list of parse trees without probabilities.
		"""
		# Calculate the total probability of the parse trees
		total_prob = sum(prob for _, prob in parse_trees_with_probs)
		def remove_probabilities(item):
			if isinstance(item, tuple):
				# If the tuple length is 3 and the third element is a float, remove it
				if len(item) == 3 and isinstance(item[2], float):
					return remove_probabilities(item[:2])
				# If the tuple length is 2 and the second element is a float, remove it
				elif len(item) == 2 and isinstance(item[1], float):
					return remove_probabilities(item[0])
				# Otherwise, process each element of the tuple
				else:
					return tuple(remove_probabilities(sub_item) for sub_item in item)
			else:
				return item
		
		return total_prob, [remove_probabilities(item[0]) for item in parse_trees_with_probs]
	

	def visualize_parse_trees(self, parse_trees_with_probs: list, word: str, prob: bool = True) -> None:
		"""
		Visualizes the parse trees with their probabilities using networkx and matplotlib.

		Parameters
		----------
		parse_trees_with_probs (list): A list of tuples with parse trees and their probabilities.
		prob (bool): Whether the parse trees are probabilistic. Default is True.
		"""
		def add_nodes_edges(tree, graph: nx.DiGraph, parent: str|None = None, order: list = [0], layer: int = 0, idx: int = 0):
			"""
			Recursively adds nodes and edges to the networkx DiGraph.

			Parameters
			----------
			tree (Any): The current subtree.
			graph (nx.DiGraph): The networkx DiGraph object.
			parent (str, optional): The parent node identifier.
			order (list): A list containing a single integer to keep track of the order of edges.
			layer (int): The current layer of the node.
			idx (int): The index of the current tree to ensure unique node identifiers.
			"""
			if isinstance(tree, tuple) and len(tree) == 3:
				symbol, left, right = tree
				node_id = f'{symbol}_{id(tree)}_{idx}'
				graph.add_node(node_id, label=symbol, layer=layer)
				
				if parent:
					order[0] += 1
					graph.add_edge(parent, node_id, label=f'{order[0]}')
				
				add_nodes_edges(left, graph, node_id, order, layer + 1, idx)
				add_nodes_edges(right, graph, node_id, order, layer + 1, idx)
			
			elif isinstance(tree, tuple) and len(tree) == 2:
				symbol, terminal = tree
				node_id = f'{symbol}_{id(tree)}_{idx}'
				graph.add_node(node_id, label=symbol, layer=layer)
				
				if parent:
					order[0] += 1
					graph.add_edge(parent, node_id, label=f'{order[0]}')
				
				terminal_id = f'{terminal}_{id(tree)}_{idx}'
				graph.add_node(terminal_id, label=terminal, layer=layer + 1)
				graph.add_edge(node_id, terminal_id, label=f'{order[0]}')
			
			else:
				node_id = f'{tree}_{id(tree)}_{idx}'
				graph.add_node(node_id, label=str(tree), layer=layer)
				
				if parent:
					order[0] += 1
					graph.add_edge(parent, node_id, label=f'{order[0]}')

		graph = nx.DiGraph()
		pos = {}
		y_offset = 0

		total_prob = None
		if prob:
			total_prob, parse_trees_with_probs = self.__transform_probabilistic_to_deterministic(parse_trees_with_probs)
		
		for idx, item in enumerate(parse_trees_with_probs):
			tree = item
			root_id = f'{tree[0]}_{id(tree)}_{idx}'
			root_label = tree[0]
			graph.add_node(root_id, label=root_label, layer=0)

			add_nodes_edges(tree, graph, root_id, [0], 1, idx)

			subtree_pos = nx.multipartite_layout(graph, subset_key='layer')
			subtree_pos = {k: (x, y + y_offset) for k, (x, y) in subtree_pos.items()}
			pos.update(subtree_pos)
			y_offset -= 3

		labels = nx.get_node_attributes(graph, 'label')
		edge_labels = nx.get_edge_attributes(graph, 'label')
		
		plt.figure(figsize=(20, 12))
		nx.draw(graph, pos, labels=labels, with_labels=True, node_size=3000, node_color='lightblue', font_size=10, font_weight='bold', arrows=True, arrowsize=20)
		nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels, font_size=10, font_color='red')
		
		title = f'Parse Trees for "{word}"'
		if prob:
			title = f'Parse Trees for "{word}" with Total Probability {total_prob:.4f}'
		
		plt.title(title)
		plt.show()