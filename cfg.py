from typing import Any, Self
import warnings

class CFG:
	"""
	A class to represent a Context-Free Grammar (CFG) and provide methods to work with it.
	"""
	
	EPSILON = 'Îµ'

	def __init__(self, rules: dict, start_symbol: str|None=None) -> None:
		"""
		Initializes the CKY parser with a given Context-Free Grammar (CFG).

		The CFG is stored in Chomsky Normal Form (CNF) internally, so the rules are converted to CNF if they are not already in CNF.

		Parameters
		----------
		rules (dict): A dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.
		start_symbol (str, optional): The start symbol of the grammar. 
			If not provided, the first symbol is inferred checking all the productions generated by each symbol.
		"""
		self.rules: dict = rules

		self.assert_valid_format()
		self.replace_epsilon()

		self.terminals, self.non_terminals = self.find_symbols(start_symbol=start_symbol)

		if not self.check_cnf():
			warnings.warn("The provided CFG is not in CNF. Converting to CNF. Some productions and symbols may change.", UserWarning)
			self.to_cnf()

		self.start_symbol: str = start_symbol if start_symbol is not None else self.find_start_symbol()

	def __call__(self, symbol: str) -> list:
		"""
		Allows the CFG object to be called as a function to get the productions for a given symbol.

		Parameters
		----------
		symbol (str): The symbol for which to get the productions.

		Returns
		-------
		list
			List of productions for the given symbol.
		"""
		return self.get_productions(symbol)
	
	def assert_valid_format(self) -> None:
		"""
		Asserts that the format of the grammar is valid.

		The grammar must be in the form of a dictionary with the keys as symbols and the values as lists of productions.
		Each symbol must be a string and each production must be a string of symbols.

		Raises
		------
		ValueError
			If the grammar is not in the correct format.
		"""
		if not isinstance(self.rules, dict):
			raise ValueError("The grammar must be provided as a dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.")
		
		for symbol, productions in self.rules.items():
			if not isinstance(symbol, str):
				raise ValueError("All symbols must be strings.")
			if len(symbol) != 1:
				raise ValueError("All symbols must be single characters (strings of length 1).")
			
			if not isinstance(productions, list|set|tuple):
				raise ValueError("The set of productions for each symbol must be a list, set, or tuple of strings.")
			
			for production in productions:
				if not isinstance(production, str):
					raise ValueError("All individual productions must be strings.")

	def replace_epsilon(self) -> None:
		"""
		Replaces empty strings with the epsilon symbol in the grammar.
		"""
		for symbol, productions in self.rules.items():
			for production in productions:
				if production == "":
					productions.remove(production)
					productions.append(self.EPSILON)

	def find_symbols(self, start_symbol: str|None) -> tuple[set, set]:
		"""
		Finds the terminal and non-terminal symbols in the grammar.

		The terminal symbols are the ones that are only produced and never produce any other symbol,
		while the non-terminal symbols are the ones that produce other symbols.

		Parameters
		----------
		start_symbol (str, optional): The start symbol specified by the user.

		Returns
		-------
		tuple[set, set]
			A tuple containing the terminal and non-terminal symbols.

		Raises
		------
		ValueError
			If there are symbols that produce other symbols but are not produced by any other symbol (cannot be reached).
		"""
		non_terminals = set(char for char in self.rules.keys())

		terminals = set()
		non_terminals_produced = set()
		for productions in self.rules.values():
			for production in productions:
				for char in production:
					if char not in non_terminals:
						terminals.add(char)
					else:
						non_terminals_produced.add(char)

		if start_symbol is not None:
			not_reached = non_terminals - non_terminals_produced
			if not_reached and not_reached.pop() != start_symbol:
				raise ValueError("The grammar is not correct. Some symbols produce other symbols but are not produced by any other symbol (cannot be reached).")

		return terminals, non_terminals
	
	def find_start_symbol(self) -> str:
		"""
		Finds the start symbol of the grammar.

		Returns
		-------
		str
			The start symbol of the grammar.

		Raises
		------
		ValueError
			If the start symbol cannot be inferred from the grammar rules.
		"""
		producted_symbols = set()
		for productions in self.rules.values():
			for production in productions:
				for char in production:
					producted_symbols.add(char)

		candidates = self.non_terminals - producted_symbols

		if not candidates or len(candidates) > 1:
			raise ValueError("Could not infer the start symbol, more than 1 candidate found.  Please provide the start symbol explicitly and ensure that the grammar is correct.")

		start_symbol = candidates.pop() # Get the non-terminal symbol that is not produced by any other symbol

		return start_symbol
	
	def check_cnf(self) -> bool:
		"""
		Checks if the grammar is in Chomsky Normal Form (CNF).

		A CFG is in CNF if all its rules are of the form:
		- A -> a, where A is a non-terminal symbol and a is a terminal symbol.
		- A -> BC, where A, B, and C are non-terminal symbols.

		Returns
		-------
		bool
			True if the grammar is in CNF, False otherwise.
		"""
		for symbol, productions in self.rules.items():
			for production in productions:
				if len(production) == 1:
					if not self.is_terminal(production):
						return False
				
				elif len(production) == 2:
					if any(not self.is_non_terminal(char) for char in production):
						return False
				
				else:
					return False
		
		return True
	
	def to_cnf(self) -> None:
		"""
		Converts the grammar to Chomsky Normal Form (CNF).

		A CFG is in CNF if all its rules are of the form:
		- A -> a, where A is a non-terminal symbol and a is a terminal symbol.
		- A -> BC, where A, B, and C are non-terminal symbols.
		"""		
		pass
	
	def is_terminal(self, symbol: str) -> bool:
		"""
		Checks if a given symbol is a terminal symbol in the grammar.

		Parameters
		----------
		symbol (str): The symbol to check.

		Returns
		-------
		bool
			True if the symbol is a terminal symbol, False otherwise.
		"""
		return symbol in self.terminals
	
	def is_non_terminal(self, symbol: str) -> bool:
		"""
		Checks if a given symbol is a non-terminal symbol in the grammar.

		Parameters
		----------
		symbol (str): The symbol to check.

		Returns
		-------
		bool
			True if the symbol is a non-terminal symbol, False otherwise.
		"""
		return symbol in self.non_terminals
	
	def get_start_symbol(self) -> str:
		"""
		Returns the start symbol of the grammar.

		Returns
		-------
		str
			The start symbol of the grammar.
		"""
		return self.start_symbol

	def get_terminal_symbols(self) -> set:
		"""
		Returns the set of terminal symbols in the grammar.

		Returns
		-------
		set
			Set of terminal symbols.
		"""
		return self.terminals
	
	def get_non_terminal_symbols(self) -> set:
		"""
		Returns the set of non-terminal symbols in the grammar.

		Returns
		-------
		set
			Set of non-terminal symbols.
		"""
		return self.non_terminals
	
	def get_productions(self, symbol: str) -> list:
		"""
		Returns the list of productions for a given symbol.

		Parameters
		----------
		symbol (str): The symbol for which to get the productions.

		Returns
		-------
		list
			List of productions for the given symbol.
		"""
		return self.rules.get(symbol, [])
	
	def get_rules(self) -> dict:
		"""
		Returns the rules of the grammar.

		Returns
		-------
		dict
			Dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.
		"""
		return self.rules
	
	def set_rules(self, rules: dict) -> None:
		"""
		Sets the rules of the grammar.

		Parameters
		----------
		rules (dict): A dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.
		"""
		self.__init__(rules)

	def __str__(self) -> str:
		"""
		Creates a string representation of the CFG object.

		Returns
		-------
		str
			String representation of the CFG object.
		"""
		dict_string = '\n'.join(f"\t{key} --> {' | '.join(sorted(value))}" for key, value in self.rules.items())
		terminals_string = ', '.join(sorted(self.terminals))
		non_terminals_string = ', '.join(sorted(self.non_terminals))
		
		return f"CFG(\n{dict_string}\n)\n" \
			f"\n* Start Symbol: {self.start_symbol}" \
			f"\n* Terminal Symbols: {{{terminals_string}}}" \
			f"\n* Non-Terminal Symbols: {{{non_terminals_string}}}"