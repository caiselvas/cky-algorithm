import warnings

class CFG:
    """
    A class to represent a Context-Free Grammar (CFG) and provide methods to work with it.
    """

    EPSILON = 'ε'

    def __init__(self, rules: dict, start_symbol: str|None=None) -> None:
        """
        Initializes the CKY parser with a given Context-Free Grammar (CFG).

        The CFG is stored in Chomsky Normal Form (CNF) internally, so the rules are converted to CNF if they are not already in CNF.

        The symbols must be single characters (strings of length 1): uppercase for non-terminal symbols and lowercase for terminal symbols.

        Parameters
        ----------
        rules (dict): A dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.
        start_symbol (str, optional): The start symbol of the grammar. 
            If not provided, the first symbol is inferred checking all the productions generated by each symbol.
        """
        self.rules: dict = rules

        self.assert_valid_format()
        self.replace_epsilon()

        self.terminals, self.non_terminals = self.find_symbols(start_symbol=start_symbol)

        self.start_symbol: str = start_symbol if start_symbol is not None else self.find_start_symbol()

        if not self.check_cnf():
            warnings.warn("The provided CFG is not in CNF. Converting to CNF. Some productions and symbols may change.", UserWarning)
            self.to_cnf()

    def __call__(self, symbol: str) -> list:
        """
        Allows the CFG object to be called as a function to get the productions for a given symbol.

        Parameters
        ----------
        symbol (str): The symbol for which to get the productions.

        Returns
        -------
        list
            List of productions for the given symbol.
        """
        return self.get_productions(symbol)
    
    def assert_valid_format(self) -> None:
        """
        Asserts that the format of the grammar is valid.

        The grammar must be in the form of a dictionary with the keys as symbols and the values as lists of productions.
        Each symbol must be a string and each production must be a string of symbols.

        Raises
        ------
        ValueError
            If the grammar is not in the correct format.
        """
        if not isinstance(self.rules, dict):
            raise ValueError("The grammar must be provided as a dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.")
        
        for symbol, productions in self.rules.items():
            if not isinstance(symbol, str):
                raise ValueError("All symbols must be strings.")
            if len(symbol) != 1:
                raise ValueError("All symbols must be single characters (strings of length 1).")
            
            if not isinstance(productions, list|set|tuple):
                raise ValueError("The set of productions for each symbol must be a list, set, or tuple of strings.")
            
            for production in productions:
                if not isinstance(production, str):
                    raise ValueError("All individual productions must be strings.")

    def replace_epsilon(self) -> None:
        """
        Replaces empty strings with the epsilon symbol (ε) in the grammar rules.
        """
        for symbol, productions in self.rules.items():
            for production in productions:
                if production == "":
                    productions.remove(production)
                    productions.append(self.EPSILON)

    def find_symbols(self, start_symbol: str|None) -> tuple[set, set]:
        """
        Finds the terminal and non-terminal symbols in the grammar, checks if they are in the correct format, and returns them.

        The terminal symbols are the ones that are only produced and never produce any other symbol,
        while the non-terminal symbols are the ones that produce other symbols and can be produced by other symbols.

        Parameters
        ----------
        start_symbol (str, None): The start symbol specified by the user.

        Returns
        -------
        tuple[set, set]
            A tuple containing the terminal and non-terminal symbols.

        Raises
        ------
        ValueError
            If the terminal symbols are not lowercase or the non-terminal symbols are not uppercase.
        ValueError
            If there are symbols that produce other symbols but are not produced by any other symbol (cannot be reached).
        """
        non_terminals = set(char for char in self.rules.keys())

        if any(not symbol.isupper() for symbol in non_terminals):
            raise ValueError("The grammar is not correct. All non-terminal symbols must be uppercase.")

        terminals = set()
        non_terminals_produced = set()
        for productions in self.rules.values():
            for production in productions:
                for char in production:
                    if char not in non_terminals:
                        terminals.add(char)
                    else:
                        non_terminals_produced.add(char)

        if any(not symbol.islower() for symbol in terminals):
            raise ValueError("The grammar is not correct. All terminal symbols must be lowercase.")

        if start_symbol is not None:
            not_reached = non_terminals - non_terminals_produced
            if not_reached and not_reached.pop() != start_symbol:
                raise ValueError("The grammar is not correct. Some symbols produce other symbols but are not produced by any other symbol (cannot be reached).")

        return terminals, non_terminals
    
    def find_start_symbol(self) -> str:
        """
        Finds the start symbol of the grammar.

        Returns
        -------
        str
            The start symbol of the grammar.

        Raises
        ------
        ValueError
            If the start symbol cannot be inferred from the grammar rules.
        """
        produced_symbols = set()
        for productions in self.rules.values():
            for production in productions:
                for char in production:
                    produced_symbols.add(char)

        candidates = self.non_terminals - produced_symbols

        if not candidates or len(candidates) > 1:
            raise ValueError("Could not infer the start symbol, more than 1 candidate found.  Please provide the start symbol explicitly and ensure that the grammar is correct.")

        start_symbol = candidates.pop() # Get the non-terminal symbol that is not produced by any other symbol

        return start_symbol
    
    def check_cnf(self) -> bool:
        """
        Checks if the grammar is in Chomsky Normal Form (CNF).

        A CFG is in CNF if all its rules are of the form:
        - A -> a, where A is a non-terminal symbol and a is a terminal symbol.
        - A -> BC, where A, B, and C are non-terminal symbols.

        Returns
        -------
        bool
            True if the grammar is in CNF, False otherwise.
        """
        for symbol, productions in self.rules.items():
            for production in productions:
                if len(production) == 1:
                    if not self.is_terminal(production):
                        return False
                
                elif len(production) == 2:
                    if any(not self.is_non_terminal(char) for char in production):
                        return False
                
                else:
                    return False
        
        return True
    
    def to_cnf(self) -> None:
        """
        Converts the grammar to Chomsky Normal Form (CNF).

        A CFG is in CNF if all its rules are of the form:
        - A -> a, where A is a non-terminal symbol and a is a terminal symbol.
        - A -> BC, where A, B, and C are non-terminal symbols.
        """
        self.eliminate_epsilon()
        self.eliminate_unit_productions()
        self.eliminate_terminal_rules()
        self.eliminate_long_productions()
        # Update the terminals, non-terminals, and start symbol

        print('caigei1')
        self.terminals, self.non_terminals = self.find_symbols(start_symbol=self.start_symbol)
        print('caigei2')
        self.start_symbol = self.find_start_symbol()
        print('caigei3')
		
    def eliminate_epsilon(self):
        """
        Eliminates epsilon (ε) productions from the grammar.
        """
        nullable = {symbol for symbol, productions in self.rules.items() if self.EPSILON in productions}

        while True:
            new_nullable = nullable.copy()
            for symbol, productions in self.rules.items():
                for production in productions:
                    if all(char in nullable for char in production):
                        new_nullable.add(symbol)
            if new_nullable == nullable:
                break
            nullable = new_nullable

        new_rules = {}
        for symbol, productions in self.rules.items():
            new_productions = set()
            for production in productions:
                new_productions.update(self.generate_combinations(production, nullable))
            if self.EPSILON in new_productions and symbol != self.start_symbol:
                new_productions.remove(self.EPSILON)
            new_rules[symbol] = list(new_productions)
        
        self.rules = new_rules

    def generate_combinations(self, production, nullable):
        """
        Generates all combinations of a production by removing nullable symbols.

        Parameters
        ----------
        production (str): The production to generate combinations for.
        nullable (set): The set of nullable symbols.

        Returns
        -------
        set
            A set of all possible combinations of the production with nullable symbols removed.
        """
        combinations = {''}
        for char in production:
            if char in nullable:
                combinations.update({c + char for c in combinations})
            combinations = {c + char for c in combinations}
        return combinations

    def eliminate_unit_productions(self):
        """
        Eliminates unit productions of the form A -> B where both A and B are non-terminal symbols.
        """
        unit_productions = [(A, B) for A, productions in self.rules.items() for B in productions if len(B) == 1 and B in self.non_terminals]
        
        while unit_productions:
            A, B = unit_productions.pop()
            self.rules[A].remove(B)
            for production in self.rules[B]:
                if production not in self.rules[A]:
                    self.rules[A].append(production)
                if len(production) == 1 and production in self.non_terminals:
                    unit_productions.append((A, production))

    def eliminate_terminal_rules(self):
        """
        Replaces terminal symbols in rules with length > 1 by introducing new non-terminal symbols.
        """
        new_rules = {}
        terminal_map = {}
        
        for non_terminal, productions in self.rules.items():
            new_productions = []
            for production in productions:
                if len(production) > 1:
                    new_production = ""
                    for symbol in production:
                        if self.is_terminal(symbol):
                            if symbol not in terminal_map:
                                new_non_terminal = self.get_new_non_terminal()
                                terminal_map[symbol] = new_non_terminal
                                new_rules[new_non_terminal] = [symbol]
                            new_production += terminal_map[symbol]
                        else:
                            new_production += symbol
                    new_productions.append(new_production)
                else:
                    new_productions.append(production)
            self.rules[non_terminal] = new_productions
        
        self.rules.update(new_rules)

    def eliminate_long_productions(self):
        """
        Breaks down productions with more than 2 non-terminal symbols on the right-hand side into binary productions.
        """
        new_rules = {}
        
        for non_terminal, productions in self.rules.items():
            new_productions = []
            for production in productions:
                while len(production) > 2:
                    new_non_terminal = self.get_new_non_terminal()
                    new_productions.append(production[:2] + new_non_terminal)
                    production = new_non_terminal + production[2:]
                new_productions.append(production)
            new_rules[non_terminal] = new_productions
        
        self.rules = new_rules

    def get_new_non_terminal(self) -> str:
        """
        Generates a new non-terminal symbol that does not conflict with existing symbols.

        Returns
        -------
        str
            A new non-terminal symbol.
        """
        import string
        for char in string.ascii_uppercase:
            if char not in self.non_terminals:
                self.non_terminals.add(char)
                return char
        raise ValueError("Ran out of unique non-terminal symbols.")

    def is_terminal(self, symbol: str) -> bool:
        """
        Checks if a given symbol is a terminal symbol in the grammar.

        Parameters
        ----------
        symbol (str): The symbol to check.

        Returns
        -------
        bool
            True if the symbol is a terminal symbol, False otherwise.
        """
        return symbol in self.terminals
    
    def is_non_terminal(self, symbol: str) -> bool:
        """
        Checks if a given symbol is a non-terminal symbol in the grammar.

        Parameters
        ----------
        symbol (str): The symbol to check.

        Returns
        -------
        bool
            True if the symbol is a non-terminal symbol, False otherwise.
        """
        return symbol in self.non_terminals
    
    def get_start_symbol(self) -> str:
        """
        Returns the start symbol of the grammar.

        Returns
        -------
        str
            The start symbol of the grammar.
        """
        return self.start_symbol

    def get_terminal_symbols(self) -> set:
        """
        Returns the set of terminal symbols in the grammar.

        Returns
        -------
        set
            Set of terminal symbols.
        """
        return self.terminals
    
    def get_non_terminal_symbols(self) -> set:
        """
        Returns the set of non-terminal symbols in the grammar.

        Returns
        -------
        set
            Set of non-terminal symbols.
        """
        return self.non_terminals
    
    def get_productions(self, symbol: str) -> list:
        """
        Returns the list of productions for a given symbol.

        Parameters
        ----------
        symbol (str): The symbol for which to get the productions.

        Returns
        -------
        list
            List of productions for the given symbol.
        """
        return self.rules.get(symbol, [])
    
    def get_rules(self) -> dict:
        """
        Returns the rules of the grammar.

        Returns
        -------
        dict
            Dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.
        """
        return self.rules
    
    def set_rules(self, rules: dict) -> None:
        """
        Sets the rules of the grammar.

        Parameters
        ----------
        rules (dict): A dictionary of rules in the form of {Symbol: [Production1, Production2, ...], ...}.
        """
        self.__init__(rules)

    def __str__(self) -> str:
        """
        Returns a string that represents the CFG object in a readable format.

        Returns
        -------
        str
            String showing the CFG object in a readable format.
        """
        dict_string = '\n'.join(f"\t{key} --> {' | '.join(sorted(value))}" for key, value in self.rules.items())
        terminals_string = ', '.join(sorted(self.terminals))
        non_terminals_string = ', '.join([self.start_symbol] + list(sorted(self.non_terminals - {self.start_symbol})))
        
        return f"CFG(\n{dict_string}\n)\n" \
            f"\n* Start Symbol: {self.start_symbol}" \
            f"\n* Terminal Symbols: {{{terminals_string}}}" \
            f"\n* Non-Terminal Symbols: {{{non_terminals_string}}}"

# Definir la gramática de ejemplo
rules = {
    'S': ['AB', 'a'],
    'A': ['BC', 'ε'],
    'B': ['b', 'A'],
    'C': ['c']
}

# Crear una instancia de la clase CFG
cfg = CFG(rules, start_symbol='S')

# Convertir la gramática a CNF
cfg.to_cnf()

# Imprimir la gramática convertida
print(cfg)
